package imitation_insert

import (
	"ISM_LAB1/converters"
)

var TABLE = [8][16]byte{
	{0xF, 0xC, 0x2, 0xA, 0x6, 0x4, 0x5, 0x0, 0x7, 0x9, 0xE, 0xD, 0x1, 0xB, 0x8, 0x3},
	{0xB, 0x6, 0x3, 0x4, 0xC, 0xF, 0xE, 0x2, 0x7, 0xD, 0x8, 0x0, 0x5, 0xA, 0x9, 0x1},
	{0x1, 0xC, 0xB, 0x0, 0xF, 0xE, 0x6, 0x5, 0xA, 0xD, 0x4, 0x8, 0x9, 0x3, 0x7, 0x2},
	{0x1, 0x5, 0xE, 0xC, 0xA, 0x7, 0x0, 0xD, 0x6, 0x2, 0xB, 0x4, 0x9, 0x3, 0xF, 0x8},
	{0x0, 0xC, 0x8, 0x9, 0xD, 0x2, 0xA, 0xB, 0x7, 0x3, 0x6, 0x5, 0x4, 0xE, 0xF, 0x1},
	{0x8, 0x0, 0xF, 0x3, 0x2, 0x5, 0xE, 0xB, 0x1, 0xA, 0x4, 0x7, 0xC, 0x9, 0xD, 0x6},
	{0x3, 0x0, 0x6, 0xF, 0x1, 0xE, 0x9, 0x2, 0xD, 0x8, 0xC, 0x4, 0xB, 0xA, 0x5, 0x7},
	{0x1, 0xA, 0x6, 0x8, 0xF, 0xB, 0x0, 0x4, 0xC, 0x3, 0x5, 0x9, 0x7, 0xD, 0x2, 0xE},
}

func splitUint64ToUint32(block uint64) (uint32, uint32) {
	return uint32(block), uint32(block >> 32)
}

func joinUint32ToUint64(N1 uint32, N2 uint32) uint64 {
	res := uint64(N1)
	res += uint64(N2) << 32
	return res
}

func Pow(x uint64, y uint64) uint64 {
	res := uint64(1)
	for i := uint64(0); i < y; i++ {
		res *= x
	}

	return res
}

func splitUint32To8Parts(block uint32) [8]byte {
	res := [8]byte{}
	for i := 0; i < 8; i++ {
		res[i] = byte((block >> (4 * i)) & uint32(0xF))
	}

	return res
}

func join8PartsToUint32(block [8]byte) uint32 {
	res := uint32(0)
	for i := 0; i < 8; i++ {
		res += uint32(block[i]) << (4 * i)
	}

	return res
}

func MainStep(block uint64, keyPart uint32) uint64 {
	N1, N2 := splitUint64ToUint32(block)
	S := uint32((uint64(N1) + uint64(keyPart)) % Pow(2, 32))
	SArr := splitUint32To8Parts(S)
	for i := 0; i < 8; i++ {
		SArr[i] = TABLE[i][SArr[i]]
	}
	S = join8PartsToUint32(SArr)
	//S <<= 11
	S = ((S << 11) | (S >> (-11 & (32 - 1)))) & ((1 << 32) - 1)
	S = S ^ N2
	//N2, N1 = N1, S
	return joinUint32ToUint64(N2, S)
}

func Loop16Z(block uint64, key [8]uint32) uint64 {
	resBlock := block
	for k := 0; k < 2; k++ {
		for j := 0; j < 8; j++ {
			resBlock = MainStep(resBlock, key[j])
		}
	}

	return resBlock
}

func DevImitationInsert(data []byte, key [8]uint32) (uint32, error) {
	// выравниваем
	for len(data)%8 != 0 {
		data = append(data, 0)
	}

	blockArr, err := converters.ConvertByteArrToUint64Arr(data)
	if err != nil {
		return 0, err
	}

	S := uint64(0)
	for i := 0; i < len(blockArr); i++ {
		S = Loop16Z(S^blockArr[i], key)
	}

	//S = Loop16Z(S, key)

	return uint32(S), nil
}

//cdce1c6c
